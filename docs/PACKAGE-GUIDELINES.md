# Package Development Guidelines

> **Note for Cursor**: This file is referenced by `AGENTS.md`. For complete package development rules, see both this file and [`AGENTS.md`](../AGENTS.md).

This document contains detailed guidelines for creating, developing, and maintaining packages in this monorepo.

## Package Naming Convention

All packages follow the pattern: `@jmlweb/{tool}-config-{variant}`

Examples:

- `@jmlweb/prettier-config-base`
- `@jmlweb/prettier-config-tailwind`
- `@jmlweb/eslint-config-base` (TypeScript, default)
- `@jmlweb/eslint-config-base-js` (JavaScript-only)

## Versioning

All packages follow semantic versioning (semver):

- **MAJOR**: Breaking changes
- **MINOR**: New features (backward compatible)
- **PATCH**: Bug fixes (backward compatible)

## Creating New Packages

When creating a new configuration package:

1. **Check for existing base packages** to extend rather than duplicate
2. **Follow naming convention**: `@jmlweb/{tool}-config-{variant}`
3. **Create minimal structure**:

   ```text
   packages/{package-name}/
   ├── src/
   │   └── index.ts   # Configuration export (TypeScript)
   ├── package.json   # Package metadata
   ├── tsconfig.json # TypeScript configuration
   ├── tsup.config.ts # Build configuration (if needed)
   └── README.md      # Usage documentation
   ```

4. **Set appropriate `engines.node`** based on features used
5. **Use `workspace:*`** for internal dependencies
6. **Add peer dependencies** for tools the config requires
7. **Follow package.json structure guidelines** (see below)
8. **Configure build system** if package requires compilation (see below)
9. **Set up TypeScript configuration** (see below)
10. **Create README** following standard structure (see [`packages/AGENTS.md`](../packages/AGENTS.md))

## Package.json Structure

All packages must follow a consistent `package.json` structure to ensure proper publishing and consumption.

### Required Fields

The following fields are required for all published packages:

- `name`: Must follow `@jmlweb/{tool}-config-{variant}` pattern
- `version`: Must follow semantic versioning (e.g., `1.0.0`)
- `description`: Clear, concise description of the package
- `author`: Package author (use `"jmlweb"`)
- `license`: Always `"MIT"`
- `repository`: Object with `type: "git"` and `url` pointing to GitHub repository
- `files`: Array of files/directories to include in published package (typically `["dist", "README.md", "CHANGELOG.md"]`)

### Recommended Fields

These fields are recommended but not strictly required:

- `engines.node`: Minimum Node.js version (e.g., `">=18.0.0"`)
- `keywords`: Array of keywords for npm search
- `bugs`: Object with `url` pointing to GitHub issues
- `homepage`: URL to package README on GitHub

### Package Exports

All packages that export code must use the modern `exports` field for dual ESM/CJS support:

```json
{
  "type": "module",
  "main": "./dist/index.cjs",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "require": {
        "types": "./dist/index.d.cts",
        "default": "./dist/index.cjs"
      },
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      }
    }
  }
}
```

This structure ensures:

- CommonJS compatibility via `require`
- ESM compatibility via `import`
- TypeScript type definitions for both module systems
- Proper resolution for both `.js` and `.ts` consumers

### Files Field

The `files` field controls what gets published to npm. Always include:

- `dist`: Built output directory (if package requires building)
- `README.md`: Package documentation
- `CHANGELOG.md`: Version history (auto-generated by Changesets)

Do not include:

- Source files (`src/`)
- Build configuration (`tsup.config.ts`, `tsconfig.json`)
- Development dependencies
- Test files

### Publish Configuration

All packages must include:

```json
{
  "publishConfig": {
    "access": "public"
  }
}
```

This ensures packages are published as public packages under the `@jmlweb` scope.

## Build System

Packages that require TypeScript compilation or bundling use `tsup` as the build tool.

### When to Use tsup

Use `tsup` when:

- Package is written in TypeScript
- Package needs to support both ESM and CommonJS
- Package needs type definitions generated

Do not use `tsup` when:

- Package is pure JavaScript with no compilation needed
- Package is a configuration file (e.g., `tsconfig.json`)

### tsup Configuration

Create a `tsup.config.ts` file in the package root:

```typescript
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src/index.ts'],
  format: ['cjs', 'esm'],
  dts: true,
  clean: true,
  outDir: 'dist',
  external: [
    // List all peer dependencies and workspace dependencies
    '@jmlweb/related-package',
    'peer-dependency',
  ],
});
```

**Key Configuration Options:**

- `entry`: Source file(s) to build
- `format`: Output formats (`['cjs', 'esm']` for dual support)
- `dts`: Generate TypeScript declaration files
- `clean`: Clean output directory before building
- `outDir`: Output directory (always `dist`)
- `external`: Dependencies that should not be bundled (always include peer dependencies and workspace dependencies)

### Build Scripts

All packages with a build step should include:

```json
{
  "scripts": {
    "build": "tsup",
    "clean": "rm -rf dist",
    "prepublishOnly": "node ../../scripts/validate-package.mjs && pnpm build"
  }
}
```

The `prepublishOnly` hook ensures:

- Package validation runs before publishing
- Build step executes before publishing
- Only valid, built packages are published

## Dependency Management

Understanding when to use `dependencies`, `devDependencies`, and `peerDependencies` is crucial for proper package configuration.

### Dependencies

Use `dependencies` for:

- **Workspace dependencies**: Other packages in this monorepo (use `workspace:*`)
- **Runtime dependencies**: Packages that are bundled with your package

**Example:**

```json
{
  "dependencies": {
    "@jmlweb/eslint-config-base-js": "workspace:*"
  }
}
```

### DevDependencies

Use `devDependencies` for:

- **Build tools**: `tsup`, `typescript`
- **Development tools**: `prettier`, `eslint` (when used for development)
- **Type definitions**: `@types/*` packages
- **Testing tools**: Test frameworks and utilities
- **Peer dependencies**: Include peer dependencies here for development/testing

**Example:**

```json
{
  "devDependencies": {
    "@jmlweb/tsconfig-internal": "workspace:*",
    "tsup": "^8.5.1",
    "typescript": "^5.9.3",
    "eslint": "^9.0.0"
  }
}
```

### Peer Dependencies

Use `peerDependencies` for:

- **Required runtime dependencies**: Tools that consumers must install (e.g., `prettier`, `eslint`, `typescript`)
- **Version ranges**: Use caret (`^`) to allow compatible versions

**Example:**

```json
{
  "peerDependencies": {
    "prettier": "^3.0.0",
    "eslint": "^9.0.0"
  }
}
```

**Important:**

- Peer dependencies are not installed automatically
- Consumers must install peer dependencies themselves
- Always include peer dependencies in `devDependencies` for local development
- Document peer dependencies in package README

### Workspace Dependencies

For internal dependencies within the monorepo, use `workspace:*`:

```json
{
  "dependencies": {
    "@jmlweb/base-package": "workspace:*"
  },
  "devDependencies": {
    "@jmlweb/tsconfig-internal": "workspace:*"
  }
}
```

This ensures:

- Packages reference the local workspace version during development
- CI/CD handles version resolution during publishing
- No version conflicts in the monorepo

## TypeScript Configuration

All TypeScript packages should extend `@jmlweb/tsconfig-internal` for consistent configuration.

### tsconfig.json Structure

```json
{
  "extends": "@jmlweb/tsconfig-internal/tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

**Key Points:**

- Always extend `@jmlweb/tsconfig-internal` for consistency
- Set `outDir` to `./dist` to match build output
- Include only source files in `include` (typically `src/**/*`)
- Exclude `node_modules` and `dist` directories

### TypeScript as DevDependency

TypeScript should be a `devDependency`, not a peer dependency, since:

- TypeScript is only needed for building the package
- Consumers don't need TypeScript to use the compiled package
- Type definitions are included in the published package

## Pre-publish Validation

All packages are validated before publishing using the `validate-package.mjs` script.

### Validation Checks

The validation script verifies:

- **Required fields**: All required `package.json` fields are present
- **Name format**: Package name follows `@jmlweb/` pattern
- **Version format**: Version follows semantic versioning
- **File existence**: Files listed in `files` field exist
- **README**: README.md exists
- **Build outputs**: Main, module, and types files exist (or will be created by build)
- **Exports structure**: Exports field is properly structured
- **Repository structure**: Repository field has correct format

### Using Validation

Validation runs automatically via the `prepublishOnly` hook:

```json
{
  "scripts": {
    "prepublishOnly": "node ../../scripts/validate-package.mjs && pnpm build"
  }
}
```

You can also run validation manually:

```bash
node scripts/validate-package.mjs packages/package-name
```

### Validation Errors

If validation fails:

- Fix all errors before publishing
- Warnings are informational but don't block publishing
- Common issues: missing fields, incorrect file paths, invalid version format

## Testing Guidelines

Before publishing or committing:

1. **Verify configuration works** by installing in a test project
2. **Check inheritance** works correctly for extending configs
3. **Validate peer dependencies** are correctly specified
4. **Test on minimum Node.js version** specified in `engines`
