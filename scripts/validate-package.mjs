/**
 * Package validation script for pre-publish checks.
 *
 * Validates:
 * - Required package.json fields
 * - Name format (@jmlweb/ pattern)
 * - Version format (semver)
 * - File existence (files field)
 * - README.md exists
 * - Exports structure
 * - Repository structure
 *
 * Usage:
 *   node scripts/validate-package.mjs [package-path]
 *
 * If no package-path is provided, validates the current directory.
 */

import { existsSync, readFileSync } from 'node:fs';
import { dirname, join, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));

const REQUIRED_FIELDS = [
  'name',
  'version',
  'description',
  'main',
  'types',
  'exports',
  'files',
  'author',
  'license',
  'repository',
];

const SEMVER_REGEX =
  /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;

/**
 * @typedef {object} ValidationResult
 * @property {string[]} errors
 * @property {string[]} warnings
 */

/**
 * Validates a package.json file
 * @param {string} packageDir - Path to the package directory
 * @returns {ValidationResult}
 */
function validatePackage(packageDir) {
  const errors = [];
  const warnings = [];

  const packageJsonPath = join(packageDir, 'package.json');

  if (!existsSync(packageJsonPath)) {
    errors.push(`package.json not found at ${packageJsonPath}`);
    return { errors, warnings };
  }

  const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));

  // Check required fields
  for (const field of REQUIRED_FIELDS) {
    if (!packageJson[field]) {
      errors.push(`Missing required field: ${field}`);
    }
  }

  // Validate name format
  if (packageJson.name && !packageJson.name.startsWith('@jmlweb/')) {
    errors.push(
      `Package name must start with @jmlweb/, got: ${packageJson.name}`,
    );
  }

  // Validate version format
  if (packageJson.version && !SEMVER_REGEX.test(packageJson.version)) {
    errors.push(`Invalid semver version: ${packageJson.version}`);
  }

  // Check README exists
  const readmePath = join(packageDir, 'README.md');
  if (!existsSync(readmePath)) {
    warnings.push('README.md not found');
  }

  // Validate exports structure
  if (packageJson.exports) {
    const mainExport = packageJson.exports['.'];
    if (!mainExport) {
      errors.push('exports["."] is required');
    } else {
      if (!mainExport.import) {
        errors.push('exports["."].import is required');
      }
      if (!mainExport.require) {
        errors.push('exports["."].require is required');
      }
    }
  }

  // Validate repository structure
  if (packageJson.repository) {
    if (typeof packageJson.repository === 'string') {
      // Simple format is okay
    } else if (typeof packageJson.repository === 'object') {
      if (!packageJson.repository.type || !packageJson.repository.url) {
        warnings.push('repository should have type and url fields');
      }
    }
  }

  // Check files field entries (warnings only - they may be generated by build)
  if (packageJson.files && Array.isArray(packageJson.files)) {
    for (const file of packageJson.files) {
      const filePath = join(packageDir, file);
      if (!existsSync(filePath)) {
        // This is a warning since files might be generated by the build step
        warnings.push(
          `File in "files" field not found (may be generated): ${file}`,
        );
      }
    }
  }

  return { errors, warnings };
}

/**
 * Main function
 */
function main() {
  // Determine package directory
  let packageDir = process.cwd();

  // If a path argument is provided, use it
  if (process.argv[2]) {
    packageDir = resolve(process.argv[2]);
  }

  console.log(`Validating package at: ${packageDir}\n`);

  const { errors, warnings } = validatePackage(packageDir);

  // Print warnings
  if (warnings.length > 0) {
    console.log('Warnings:');
    for (const warning of warnings) {
      console.log(`  - ${warning}`);
    }
    console.log();
  }

  // Print errors
  if (errors.length > 0) {
    console.log('Errors:');
    for (const error of errors) {
      console.log(`  - ${error}`);
    }
    console.log();
    console.log('Validation failed!');
    process.exit(1);
  }

  console.log('Validation passed!');
}

main();
